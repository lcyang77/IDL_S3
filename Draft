/*
 * SPDX-FileCopyrightText: 2022-2024 Espressif Systems (Shanghai) CO LTD
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <inttypes.h>
#include "freertos/FreeRTOS.h"
#include "freertos/event_groups.h"
#include "freertos/task.h"
#include "esp_err.h"
#include "esp_log.h"
#include "esp_wifi.h"
#include "esp_event.h"
#include "nvs_flash.h"
#include "esp_http_server.h"
#include "usb_stream.h"
#ifdef CONFIG_ESP32_S3_USB_OTG
#include "bsp/esp-bsp.h"
#endif
#include "esp_camera.h"

static const char *TAG = "uvc_demo";

/****************** configure the example working mode *******************************/
#define ENABLE_UVC_FRAME_RESOLUTION_ANY   0
#define ENABLE_UVC_WIFI_XFER              1

#define EXAMPLE_ESP_WIFI_SSID      "ASUS Wi-Fi7"
#define EXAMPLE_ESP_WIFI_PASS      "y2756096"

// Event group bits definitions
#define BIT0_FRAME_START     (0x01 << 0)
#define BIT1_NEW_FRAME_START (0x01 << 1)
#define BIT2_NEW_FRAME_END   (0x01 << 2)
#define BIT3_STREAM_READY    (0x01 << 3)

static EventGroupHandle_t s_evt_handle;
static EventGroupHandle_t s_wifi_event_group;
#define WIFI_CONNECTED_BIT BIT0
#define WIFI_FAIL_BIT      BIT1

#if (ENABLE_UVC_FRAME_RESOLUTION_ANY)
#define DEMO_UVC_FRAME_WIDTH        FRAME_RESOLUTION_ANY
#define DEMO_UVC_FRAME_HEIGHT       FRAME_RESOLUTION_ANY
#else
#define DEMO_UVC_FRAME_WIDTH        320
#define DEMO_UVC_FRAME_HEIGHT       240
#endif

#ifdef CONFIG_IDF_TARGET_ESP32S2
#define DEMO_UVC_XFER_BUFFER_SIZE (45 * 1024)
#else
#define DEMO_UVC_XFER_BUFFER_SIZE (64 * 1024)
#endif

static camera_fb_t s_fb = {0};
static bool g_streaming_active = false;

// 前向声明所有回调函数
static void camera_frame_cb(uvc_frame_t *frame, void *ptr);
static void stream_state_changed_cb(usb_stream_state_t event, void *arg);
static void wifi_event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data);
static esp_err_t stream_handler(httpd_req_t *req);
static esp_err_t capture_handler(httpd_req_t *req);

camera_fb_t *esp_camera_fb_get()
{
    // 首先检查流是否活跃
    if (!g_streaming_active) {
        ESP_LOGW(TAG, "Stream not active");
        return NULL;
    }

    // 等待流准备就绪
    EventBits_t bits = xEventGroupWaitBits(s_evt_handle, 
        BIT3_STREAM_READY, 
        pdFALSE,   // 不清除位
        pdTRUE,    // 等待所有位
        pdMS_TO_TICKS(1000));
    
    if ((bits & BIT3_STREAM_READY) != BIT3_STREAM_READY) {
        ESP_LOGW(TAG, "Stream not ready");
        return NULL;
    }

    // 清除之前可能存在的帧开始位
    xEventGroupClearBits(s_evt_handle, BIT1_NEW_FRAME_START);
    
    // 设置帧请求标志
    xEventGroupSetBits(s_evt_handle, BIT0_FRAME_START);

    // 等待新帧
    bits = xEventGroupWaitBits(s_evt_handle,
        BIT1_NEW_FRAME_START,
        pdTRUE,    // 清除标志位
        pdTRUE,    // 等待所有位
        pdMS_TO_TICKS(5000));  // 增加超时时间到5秒

    if ((bits & BIT1_NEW_FRAME_START) != BIT1_NEW_FRAME_START) {
        ESP_LOGW(TAG, "Frame timeout after 5 seconds");
        xEventGroupClearBits(s_evt_handle, BIT0_FRAME_START);
        return NULL;
    }

    return &s_fb;
}

void esp_camera_fb_return(camera_fb_t *fb)
{
    if (fb) {
        xEventGroupSetBits(s_evt_handle, BIT2_NEW_FRAME_END);
        // 等待帧结束处理完成
        xEventGroupWaitBits(s_evt_handle, 
            BIT2_NEW_FRAME_END, 
            pdTRUE,    // 清除标志位
            pdTRUE, 
            pdMS_TO_TICKS(1000));
    }
}

static esp_err_t init_uvc_device(void)
{
    esp_err_t ret = ESP_OK;
    
    /* malloc double buffer for usb payload */
    uint8_t *xfer_buffer_a = (uint8_t *)heap_caps_malloc(DEMO_UVC_XFER_BUFFER_SIZE, MALLOC_CAP_DMA);
    if (xfer_buffer_a == NULL) {
        ESP_LOGE(TAG, "Failed to allocate xfer buffer A");
        return ESP_ERR_NO_MEM;
    }
    
    uint8_t *xfer_buffer_b = (uint8_t *)heap_caps_malloc(DEMO_UVC_XFER_BUFFER_SIZE, MALLOC_CAP_DMA);
    if (xfer_buffer_b == NULL) {
        free(xfer_buffer_a);
        ESP_LOGE(TAG, "Failed to allocate xfer buffer B");
        return ESP_ERR_NO_MEM;
    }

    uint8_t *frame_buffer = (uint8_t *)heap_caps_malloc(DEMO_UVC_XFER_BUFFER_SIZE, MALLOC_CAP_DMA);
    if (frame_buffer == NULL) {
        free(xfer_buffer_a);
        free(xfer_buffer_b);
        ESP_LOGE(TAG, "Failed to allocate frame buffer");
        return ESP_ERR_NO_MEM;
    }

    uvc_config_t uvc_config = {
        .frame_width = DEMO_UVC_FRAME_WIDTH,
        .frame_height = DEMO_UVC_FRAME_HEIGHT,
        .frame_interval = FPS2INTERVAL(15),
        .xfer_buffer_size = DEMO_UVC_XFER_BUFFER_SIZE,
        .xfer_buffer_a = xfer_buffer_a,
        .xfer_buffer_b = xfer_buffer_b,
        .frame_buffer_size = DEMO_UVC_XFER_BUFFER_SIZE,
        .frame_buffer = frame_buffer,
        .frame_cb = camera_frame_cb,
        .frame_cb_arg = NULL,
        .interface = 1,  // 视频流接口号
        .interface_alt = 0,  // 备用接口设置
        .ep_addr = 0x81,  // 端点地址(IN endpoint)
        .ep_mps = 64,     // 最大数据包大小
        .xfer_type = UVC_XFER_BULK,  // 使用 BULK 传输方式
    };

    // 1. 首先注册状态回调
    ret = usb_streaming_state_register(stream_state_changed_cb, NULL);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to register state callback");
        goto cleanup;
    }

    // 2. 配置UVC流
    ret = uvc_streaming_config(&uvc_config);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "UVC streaming config failed");
        goto cleanup;
    }

    // 3. 确保之前的状态被清除
    xEventGroupClearBits(s_evt_handle, BIT3_STREAM_READY);
    g_streaming_active = false;

    // 4. 启动USB流
    ret = usb_streaming_start();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start USB streaming");
        goto cleanup;
    }

    // 5. 等待设备连接
    ret = usb_streaming_connect_wait(portMAX_DELAY);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to connect to USB device");
        goto cleanup;
    }

    // 6. 添加适当的延时等待设备准备就绪
    vTaskDelay(pdMS_TO_TICKS(100));

    // 7. 等待设备真正准备就绪
    for (int retry = 0; retry < 5; retry++) {
        if (g_streaming_active) {
            ESP_LOGI(TAG, "UVC device initialized successfully");
            return ESP_OK;
        }
        vTaskDelay(pdMS_TO_TICKS(100));
    }

    if (!g_streaming_active) {
        ESP_LOGW(TAG, "UVC device initialization timeout");
        ret = ESP_ERR_TIMEOUT;
        goto cleanup;
    }

    ESP_LOGI(TAG, "UVC device initialized successfully");
    return ESP_OK;

cleanup:
    free(xfer_buffer_a);
    free(xfer_buffer_b);
    free(frame_buffer);
    return ret;
}

static void camera_frame_cb(uvc_frame_t *frame, void *ptr)
{
    if (!frame || !g_streaming_active) {
        return;
    }

    ESP_LOGI(TAG, "uvc callback! frame_format = %d, seq = %"PRIu32", width = %"PRIu32", height = %"PRIu32", length = %u, ptr = %d",
             frame->frame_format, frame->sequence, frame->width, frame->height, frame->data_bytes, (int) ptr);

    // 检查是否有帧请求
    if (!(xEventGroupGetBits(s_evt_handle) & BIT0_FRAME_START)) {
        ESP_LOGV(TAG, "No frame request active");
        return;
    }

    switch (frame->frame_format) {
    case UVC_FRAME_FORMAT_MJPEG:
        // 更新帧缓冲区数据
        memcpy(&s_fb.buf, &frame->data, sizeof(frame->data));
        s_fb.len = frame->data_bytes;
        s_fb.width = frame->width;
        s_fb.height = frame->height;
        s_fb.format = PIXFORMAT_JPEG;
        s_fb.timestamp.tv_sec = frame->sequence;

        // 通知新帧可用
        xEventGroupSetBits(s_evt_handle, BIT1_NEW_FRAME_START);
        ESP_LOGV(TAG, "Frame ready, seq = %"PRIu32"", frame->sequence);

        // 等待帧处理完成
        EventBits_t bits = xEventGroupWaitBits(s_evt_handle,
            BIT2_NEW_FRAME_END,
            pdFALSE,  // 不清除标志位
            pdTRUE,
            pdMS_TO_TICKS(1000));

        if ((bits & BIT2_NEW_FRAME_END) != BIT2_NEW_FRAME_END) {
            ESP_LOGW(TAG, "Frame processing timeout");
        } else {
            ESP_LOGV(TAG, "Frame processed, seq = %"PRIu32"", frame->sequence);
            xEventGroupClearBits(s_evt_handle, BIT0_FRAME_START | BIT2_NEW_FRAME_END);
        }
        break;
    default:
        ESP_LOGW(TAG, "Format not supported");
        break;
    }
}

static void stream_state_changed_cb(usb_stream_state_t event, void *arg)
{
    switch (event) {
    case STREAM_CONNECTED: {
        size_t frame_size = 0;
        size_t frame_index = 0;
        esp_err_t ret = uvc_frame_size_list_get(NULL, &frame_size, &frame_index);
        if (ret != ESP_OK) {
            ESP_LOGW(TAG, "Failed to get frame size list");
            return;
        }
        
        if (frame_size) {
            ESP_LOGI(TAG, "UVC: get frame list size = %u, current = %u", frame_size, frame_index);
            uvc_frame_size_t *uvc_frame_list = (uvc_frame_size_t *)malloc(frame_size * sizeof(uvc_frame_size_t));
            if (uvc_frame_list) {
                uvc_frame_size_list_get(uvc_frame_list, NULL, NULL);
                for (size_t i = 0; i < frame_size; i++) {
                    ESP_LOGI(TAG, "\tframe[%u] = %ux%u", i, uvc_frame_list[i].width, uvc_frame_list[i].height);
                }
                free(uvc_frame_list);
            }
        } else {
            ESP_LOGW(TAG, "UVC: get frame list size = %u", frame_size);
        }
        ESP_LOGI(TAG, "Device connected");
        g_streaming_active = true;
        xEventGroupSetBits(s_evt_handle, BIT3_STREAM_READY);
        break;
    }
    case STREAM_DISCONNECTED:
        ESP_LOGI(TAG, "Device disconnected");
        g_streaming_active = false;
        xEventGroupClearBits(s_evt_handle, BIT3_STREAM_READY);
        break;
    default:
        ESP_LOGE(TAG, "Unknown event");
        break;
    }
}

static void wifi_event_handler(void* arg, esp_event_base_t event_base,
                             int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
        esp_wifi_connect();
    } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
        esp_wifi_connect();
    } else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP) {
        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;
        ESP_LOGI(TAG, "got ip:" IPSTR, IP2STR(&event->ip_info.ip));
        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);
    }
}

static esp_err_t stream_handler(httpd_req_t *req)
{
    esp_err_t res = ESP_OK;
    char part_buf[64];

    if (!g_streaming_active) {
        ESP_LOGE(TAG, "Streaming not active");
        return ESP_FAIL;
    }

    res = httpd_resp_set_type(req, "multipart/x-mixed-replace;boundary=123456789000000000000987654321");
    if (res != ESP_OK) {
        return res;
    }

    while (g_streaming_active) {
        camera_fb_t *fb = esp_camera_fb_get();
        if (!fb) {
            ESP_LOGE(TAG, "Camera capture failed");
            res = ESP_FAIL;
            break;
        }

        size_t hlen = snprintf(part_buf, sizeof(part_buf),
            "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n",
            fb->len);

        res = httpd_resp_send_chunk(req, part_buf, hlen);
        if (res == ESP_OK) {
            res = httpd_resp_send_chunk(req, (const char *)fb->buf, fb->len);
        }
        if (res == ESP_OK) {
            res = httpd_resp_send_chunk(req, "\r\n--123456789000000000000987654321\r\n", 37);
        }

        esp_camera_fb_return(fb);
        if (res != ESP_OK) {
            break;
        }
    }
    return res;
}

static esp_err_t capture_handler(httpd_req_t *req)
{
    camera_fb_t *fb = NULL;
    esp_err_t res = ESP_OK;

    if (!g_streaming_active) {
        ESP_LOGE(TAG, "Streaming not active");
        return ESP_FAIL;
    }

    fb = esp_camera_fb_get();
    if (!fb) {
        ESP_LOGE(TAG, "Camera capture failed");
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    res = httpd_resp_set_type(req, "image/jpeg");
    if (res == ESP_OK) {
        res = httpd_resp_set_hdr(req, "Content-Disposition", "inline; filename=capture.jpg");
    }

    if (res == ESP_OK) {
        res = httpd_resp_send(req, (const char *)fb->buf, fb->len);
    }

    esp_camera_fb_return(fb);
    return res;
}

void app_wifi_init(void)
{
    s_wifi_event_group = xEventGroupCreate();

    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    esp_netif_t *sta_netif = esp_netif_create_default_wifi_sta();
    assert(sta_netif);

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    ESP_ERROR_CHECK(esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &wifi_event_handler, NULL));
    ESP_ERROR_CHECK(esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &wifi_event_handler, NULL));

    wifi_config_t wifi_config = {
        .sta = {
            .ssid = EXAMPLE_ESP_WIFI_SSID,
            .password = EXAMPLE_ESP_WIFI_PASS,
        },
    };
    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());
}

void start_webserver(void)
{
    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    httpd_handle_t stream_httpd = NULL;

    httpd_uri_t stream = {
        .uri       = "/stream",
        .method    = HTTP_GET,
        .handler   = stream_handler,
        .user_ctx  = NULL
    };

    httpd_uri_t capture = {
        .uri       = "/capture",
        .method    = HTTP_GET,
        .handler   = capture_handler,
        .user_ctx  = NULL
    };

    ESP_LOGI(TAG, "Starting web server on port: '%d'", config.server_port);
    if (httpd_start(&stream_httpd, &config) == ESP_OK) {
        httpd_register_uri_handler(stream_httpd, &stream);
        httpd_register_uri_handler(stream_httpd, &capture);
    }
}

void app_main(void)
{
#ifdef CONFIG_ESP32_S3_USB_OTG
    bsp_usb_mode_select_host();
    bsp_usb_host_power_mode(BSP_USB_HOST_POWER_MODE_USB_DEV, true);
#endif
    esp_log_level_set("*", ESP_LOG_INFO);
    esp_log_level_set("httpd_txrx", ESP_LOG_INFO);

    // Initialize NVS
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Create event groups
    s_evt_handle = xEventGroupCreate();
    if (s_evt_handle == NULL) {
        ESP_LOGE(TAG, "line-%u event group create failed", __LINE__);
        assert(0);
    }

    // Initialize WiFi
    app_wifi_init();

    // Wait for WiFi connection
    xEventGroupWaitBits(s_wifi_event_group,
            WIFI_CONNECTED_BIT,
            pdFALSE,
            pdFALSE,
            portMAX_DELAY);

    // Start HTTP Server
    start_webserver();

    // Initialize and start UVC device
    ret = init_uvc_device();
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to initialize UVC device");
        vTaskDelay(portMAX_DELAY);
    }

    // Main loop
    while (1) {
        // Check stream status
        if (!g_streaming_active) {
            ESP_LOGW(TAG, "Stream inactive, attempting to reconnect...");
            ret = init_uvc_device();
            if (ret != ESP_OK) {
                ESP_LOGE(TAG, "Failed to reinitialize UVC device");
            }
            vTaskDelay(pdMS_TO_TICKS(1000)); // Wait before retry
        }
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}